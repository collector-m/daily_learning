# 控制模块

## 自动驾驶控制算法概述

![image-20240215145912829](../imgs/image-20240215145912829.png)

规划控制的内容主要在于前半截，后半截的底盘控制为另外的领域



## velocity_set模块源码解析及仿真

![image-20240215150858762](../imgs/image-20240215150858762.png)

基本大体上借助于final_waypoints的轨迹，不会有太大的变动



### 源码解析

#### velocity.cpp

路径为：`\src\autoware\core_planning\waypoint_planner\src\velocity_set\velocity_set.cpp`

- 输入

  ```
   // velocity set info subscriber
    ros::Subscriber config_sub = nh.subscribe("config/velocity_set", 1, &VelocitySetInfo::configCallback, &vs_info);
    ros::Subscriber points_sub = nh.subscribe(points_topic, 1, &VelocitySetInfo::pointsCallback, &vs_info);
    ros::Subscriber localizer_sub = nh.subscribe("localizer_pose", 1, &VelocitySetInfo::localizerPoseCallback, &vs_info);
    ros::Subscriber control_pose_sub = nh.subscribe("current_pose", 1, &VelocitySetInfo::controlPoseCallback, &vs_info);
    ros::Subscriber detectionresult_sub = nh.subscribe("/state/stopline_wpidx", 1, &VelocitySetInfo::detectionCallback, &vs_info);
  
    // vector map subscriber
    ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &CrossWalk::crossWalkCallback, &crosswalk);
    ros::Subscriber sub_area = nh.subscribe("vector_map_info/area", 1, &CrossWalk::areaCallback, &crosswalk);
    ros::Subscriber sub_line = nh.subscribe("vector_map_info/line", 1, &CrossWalk::lineCallback, &crosswalk);
    ros::Subscriber sub_point = nh.subscribe("vector_map_info/point", 1, &CrossWalk::pointCallback, &crosswalk);
  ```

- 输出

  ```
    // publisher
    ros::Publisher detection_range_pub = nh.advertise<visualization_msgs::MarkerArray>("detection_range", 1);
    ros::Publisher obstacle_pub = nh.advertise<visualization_msgs::Marker>("obstacle", 1);
    ros::Publisher obstacle_waypoint_pub = nh.advertise<std_msgs::Int32>("obstacle_waypoint", 1, true);
    ros::Publisher stopline_waypoint_pub = nh.advertise<std_msgs::Int32>("stopline_waypoint", 1, true);
  
    ros::Publisher final_waypoints_pub;
    final_waypoints_pub = nh.advertise<autoware_msgs::Lane>("final_waypoints", 1, true);
  ```

  - final_waypoints为从closed waypoint往后延一定的size的waypoints

  - final_waypoints和safety_waypoints的区别是，虽然都从closed waypoint处开始，但是final_waypoints的长度不超过TemporalWaypointsSize

```
EControl detection_result = obstacleDetection(closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info,detection_range_pub, obstacle_pub, &obstacle_waypoint);
```

跳转到以下函数



##### ObstacleDetection函数

该函数用于进行障碍物检测

```
EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint,lane,crosswalk,vs_info,obstacle_waypoint,&obstacle_points);
displayDetectionRange(lane,crosswalk,closest_waypoint,detection_result,*obstacle_waypoint,vs_info.getStopRange(),vs_info.getDecelerationRange(), detection_range_pub);
```

display即用于进行可视化



##### 再跳转到pointsDetection函数

```
EControl pointsDetection(const pcl::PointCloud<pcl::PointXYZ>& points, const int closest_waypoint,const autoware_msgs::Lane& lane, const CrossWalk& crosswalk, const VelocitySetInfo& vs_info,int* obstacle_waypoint, ObstaclePoints* obstacle_points)
```

输入为points，即为point lane，去掉地面之后的点

有没有去掉障碍物是通过点云反射来知道的，因为地面不算做障碍物，所以要把障碍物去掉



##### 再跳转到detectStopObstacle函数

```
int detectStopObstacle(const pcl::PointCloud<pcl::PointXYZ>& points, const int closest_waypoint,const autoware_msgs::Lane& lane, const CrossWalk& crosswalk, double stop_range,double points_threshold, const geometry_msgs::PoseStamped& localizer_pose,ObstaclePoints* obstacle_points, EObstacleType* obstacle_type,const int wpidx_detection_result_by_other_nodes)
```

-   从closest_waypoint开始，在设定好的范围内开始搜索

```
for (int i = closest_waypoint; i < closest_waypoint + STOP_SEARCH_DISTANCE; i++){
}
```

之后就进行正常的检查

- 将waypoints转换到lidar坐标系下

```
geometry_msgs::Point waypoint = calcRelativeCoordinate(lane.waypoints[i].pose.pose.position, localizer_pose.pose);
tf::Vector3 tf_waypoint = point2vector(waypoint);
tf_waypoint.setZ(0);
```

