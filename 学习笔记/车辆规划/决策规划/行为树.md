# 行为树(BT)

## 总述

和状态机的方法类似，将场景的**任务模块化**，与决策联系起来，换了一种方式表达，更容易被理解，可视性强

- **行为树是树**：从根节点出发，由一个特定的顺序对树进行遍历直到达到最终状态
- **叶节点是可执行的行为**：每一个叶子都会有相应的处理逻辑，要么是逻辑判断，要么是最终状态

- **节点控制树的遍历**：每一个节点都会进行处理，并应用自己的规则来指定下一个应该扩展哪个节点



## 术语

行为树由各种节点组成，可由以下6种基本图形来表达

![image-20240204152712095](../../imgs/image-20240204152712095.png)

- 第一大类：执行节点（action，condition）
- 第二大类：控制节点（selector，sequence，parallel，decorator）

- **行为树每一次离散化的更新称为tick**
- 每次tick之后会返回给父节点运行结果状态：success，failure，running



## 基于超车的例子来建立行为树

- **动作节点**：是行为树的叶子节点。

  如果动作执行成功则返回success，失败则返回failure，正在运行则返回running。例如超车状态的action node有三个动作：turn out，pass car， turn in

- **通过顺序节点连接各个动作**：**按照一定顺序执行子节点**，直到其中任一个节点返回失败的状态，或者全部子节点执行成功时，并向上层返回汇报

  ![image-20240204154846570](../../imgs/image-20240204154846570.png)

- **条件节点**：类似于简单的if语句

  如果条件检查为true，则节点返回Success；如果为false，则返回Failure；条件节点永远不会返回Running状态

  判断是否可以超车，例如前方有没有车，前方车速是否低于自车设定车速等等

<img src="../../imgs/image-20240204155006562.png" alt="image-20240204155006562" style="zoom: 50%;" />

- **是否具备安全超车条件，需要选择节点**：

  选择器节点将开始按顺序勾选其子节点，如果第一个子节点失败，执行将继续到下一个子节点，并勾选；如果一个子节点成功了，选择器也会返回成功，并且不会继续下一个

  如图有一个oncoming car，如果有，那么说明超车会有潜在风险，则不会超车

![image-20240204155518299](../../imgs/image-20240204155518299.png)

- **在某些情况下需要并行动作，则需要并行节点**：

  同时tick所有子节点，允许多个操作节点处于运行状态

  这是有引号的，因为这不是真正的并行；在每次勾选时，每个子节点将按顺序单独勾选。当至少有M个子节点（介于1和N之间）成功时，平行节点会返回成功，而当所有子节点都失败时，则返回失败

  并行节点自身报告访问/失败之前需要多少子节点才能成功的要求可以根据每个实例进行自定义

  turn in/out的时候还需要打转向灯

  ![image-20240204161021970](../../imgs/image-20240204161021970.png)

- **装饰器节点**：包装底层子树或子树的功能

  比如，它可以影响基础节点的行为或修改返回状态，常用的有逆变器(Inverter)和重复(Repeat)。其中，逆变器是将结果翻转，例如从成功变为失败；重复则是重复该子节点的所有任务

![image-20240204161619024](../../imgs/image-20240204161619024.png)



- **最终示例**：超车场景的节点图

  ![image-20240204162228274](../../imgs/image-20240204162228274.png)



## 与状态机(FSM)比较

通常情况下，BTs更容易组成和修改，而FSM在设计反应性方面更具有优势

- 超车场景

![image-20240204162655555](../../imgs/image-20240204162655555.png)

可以看出，在BTs方法中加入车辆超车速度检查更为容易



- 无车检查场景

![image-20240204162841125](../../imgs/image-20240204162841125.png)

可以看出，在FSM方法中对于检查前方车辆的反应更为敏捷



## 代码

主要关注behaivortree_cpp_v3的底层代码，即一些节点的改进所需要的必要步骤

1. 在include文件夹中，增加/修改你所要的节点的头文件（如果可以直接在.h文件中厘清该节点的逻辑，即不需要在.cpp文件中实现）
2. 如果需要修改/增加改模块的具体逻辑，可以在.cpp文件中进行编写
3. 在behavior_tree.h文件中添加头文件的路径
4. 在bt_factory.cpp文件中进行所修改/新增节点的注册
5. Groot可视化：在Groot文件夹中的NodeStyle.json文件中增加可视化图标内容
   - 在depend目录下，也有behavior_cpp_v3的底层代码，在这里面也需要按照上述1-4步骤进行修改，以便在Groot中进行可视化使用